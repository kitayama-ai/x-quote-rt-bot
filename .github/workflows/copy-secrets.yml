name: "Run Mini Tool Test"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰"
        required: true
        default: "post-test"
        type: choice
        options:
          - post-test
          - collect-only
          - dry-run

jobs:
  test-mini:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install tweepy requests-oauthlib google-genai python-dotenv

      - name: Create mini tool
        run: |
          cat > run_mini.py << 'PYEOF'
          #!/usr/bin/env python3
          """X Quote RT Mini â€” ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç‰ˆï¼ˆGitHub Actionsç”¨ï¼‰"""
          import argparse, json, os, random, re, sys, time
          from datetime import datetime, timezone

          # ç’°å¢ƒå¤‰æ•°
          X_API_KEY = os.getenv("X_API_KEY", "")
          X_API_SECRET = os.getenv("X_API_SECRET", "")
          X_ACCESS_TOKEN = os.getenv("X_ACCESS_TOKEN", "")
          X_ACCESS_SECRET = os.getenv("X_ACCESS_SECRET", "")
          TWITTER_BEARER_TOKEN = os.getenv("TWITTER_BEARER_TOKEN", "")
          GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")

          def check_env():
              envs = {"X_API_KEY": X_API_KEY, "X_API_SECRET": X_API_SECRET,
                      "X_ACCESS_TOKEN": X_ACCESS_TOKEN, "X_ACCESS_SECRET": X_ACCESS_SECRET,
                      "TWITTER_BEARER_TOKEN": TWITTER_BEARER_TOKEN, "GEMINI_API_KEY": GEMINI_API_KEY}
              missing = [k for k,v in envs.items() if not v]
              if missing:
                  print(f"âŒ æœªè¨­å®š: {', '.join(missing)}")
                  sys.exit(1)
              for k,v in envs.items():
                  print(f"  âœ… {k}: {v[:6]}...{v[-3:]} ({len(v)}å­—)")

          def post_test():
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("ğŸ§ª æŠ•ç¨¿ãƒ†ã‚¹ãƒˆï¼ˆå³å‰Šé™¤ï¼‰")
              print("="*50)

              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)

              # 1. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç¢ºèª
              print("  1ï¸âƒ£ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç¢ºèª...")
              me_resp = session.get("https://api.twitter.com/2/users/me")
              if me_resp.status_code == 200:
                  me = me_resp.json().get("data", {})
                  print(f"     âœ… @{me.get('username','?')} ({me.get('name','?')})")
              else:
                  print(f"     âš ï¸ GET /users/me: {me_resp.status_code}")

              # 2. ãƒ†ã‚¹ãƒˆæŠ•ç¨¿
              print("  2ï¸âƒ£ ãƒ†ã‚¹ãƒˆæŠ•ç¨¿...")
              test_text = f"ğŸ§ª Mini Test ({datetime.now(timezone.utc).isoformat()[:19]})"
              resp = session.post("https://api.twitter.com/2/tweets", json={"text": test_text})
              if resp.status_code not in (200, 201):
                  print(f"     âŒ æŠ•ç¨¿å¤±æ•—: {resp.status_code} {resp.json()}")
                  return False
              tweet_id = resp.json().get("data",{}).get("id","")
              print(f"     âœ… æŠ•ç¨¿æˆåŠŸ: {tweet_id}")

              # 3. å³å‰Šé™¤
              print("  3ï¸âƒ£ å³å‰Šé™¤...")
              time.sleep(1)
              del_resp = session.delete(f"https://api.twitter.com/2/tweets/{tweet_id}")
              print(f"     {'âœ…' if del_resp.status_code==200 else 'âš ï¸'} å‰Šé™¤: {del_resp.status_code}")

              # 4. å¼•ç”¨RTãƒ†ã‚¹ãƒˆ
              print("  4ï¸âƒ£ å¼•ç”¨RTãƒ†ã‚¹ãƒˆ...")
              qt_resp = session.post("https://api.twitter.com/2/tweets", json={
                  "text": f"ğŸ§ª Quote RT Test ({datetime.now(timezone.utc).isoformat()[:19]})",
                  "quote_tweet_id": "1585841080431321088",
              })
              if qt_resp.status_code in (200, 201):
                  qt_id = qt_resp.json().get("data",{}).get("id","")
                  print(f"     âœ… å¼•ç”¨RTæˆåŠŸ: {qt_id}")
                  time.sleep(1)
                  session.delete(f"https://api.twitter.com/2/tweets/{qt_id}")
                  print(f"     âœ… å‰Šé™¤å®Œäº†")
              else:
                  print(f"     âŒ å¼•ç”¨RTå¤±æ•—: {qt_resp.status_code} {qt_resp.json()}")
                  return False

              print(f"\n  ğŸ‰ å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼ï¼")
              return True

          def collect_tweets(min_likes=100, max_tweets=20):
              import tweepy
              print("\n" + "="*50)
              print("ğŸ“¡ ãƒã‚ºãƒ„ã‚¤ãƒ¼ãƒˆåé›†")
              print("="*50)

              client = tweepy.Client(bearer_token=TWITTER_BEARER_TOKEN, wait_on_rate_limit=True)
              queries = [
                  "AI OR GPT OR LLM OR OpenAI OR Claude -is:reply -is:retweet lang:en",
                  "crypto OR Bitcoin OR BTC OR Ethereum -is:reply -is:retweet lang:en",
              ]
              all_tweets = []
              for qi, query in enumerate(queries):
                  print(f"  ğŸ” ã‚¯ã‚¨ãƒª {qi+1}: {query[:50]}...")
                  try:
                      response = client.search_recent_tweets(
                          query=query, max_results=min(max_tweets, 100),
                          tweet_fields=["created_at","public_metrics","author_id","lang"],
                          user_fields=["username","name"], expansions=["author_id"],
                          sort_order="relevancy")
                  except Exception as e:
                      print(f"  âš ï¸ æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
                      continue
                  if not response or not response.data:
                      print("  â†’ çµæœãªã—"); continue
                  users = {}
                  if response.includes and "users" in response.includes:
                      for u in response.includes["users"]:
                          users[u.id] = {"username": u.username, "name": u.name}
                  count = 0
                  for tweet in response.data:
                      metrics = tweet.public_metrics or {}
                      likes = metrics.get("like_count", 0)
                      if likes < min_likes: continue
                      user = users.get(tweet.author_id, {})
                      all_tweets.append({
                          "id": str(tweet.id), "text": tweet.text,
                          "likes": likes, "retweets": metrics.get("retweet_count",0),
                          "author_username": user.get("username","unknown"),
                          "author_name": user.get("name",""),
                      })
                      count += 1
                  print(f"  â†’ API {len(response.data)}ä»¶, ãƒ•ã‚£ãƒ«ã‚¿å¾Œ {count}ä»¶")
              # dedup & sort
              seen = set(); unique = []
              for t in all_tweets:
                  if t["id"] not in seen: seen.add(t["id"]); unique.append(t)
              unique.sort(key=lambda x: x["likes"], reverse=True)
              print(f"\nğŸ“Š åé›†çµæœ: {len(unique)}ä»¶ï¼ˆ{min_likes}ã„ã„ã­ä»¥ä¸Šï¼‰")
              for i, t in enumerate(unique[:5]):
                  print(f"  [{i+1}] â¤ï¸{t['likes']:,} ğŸ”„{t['retweets']:,} @{t['author_username']}")
                  print(f"      {t['text'][:80]}...")
              return unique

          def generate_comment(tweet):
              from google import genai
              print("\n" + "="*50)
              print("ğŸ¤– å¼•ç”¨RTã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆ")
              print("="*50)

              client = genai.Client(api_key=GEMINI_API_KEY)
              templates = [
                  ("translate_comment","å¸‚å ´ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆå‹"),("summary_points","è¦ç‚¹ã¾ã¨ã‚å‹"),
                  ("breaking_news","è¡æ’ƒé€Ÿå ±å‹"),("dark_alert","ãƒ€ãƒ¼ã‚¯è­¦å‘Šå‹"),
              ]
              tid, tname = random.choice(templates)
              prompt = f"""ã‚ãªãŸã¯ğ•ã§æš—å·è³‡ç”£ãƒ»Web3ãƒ»AIã‚’ãƒ†ãƒ¼ãƒã«ç™ºä¿¡ã—ã¦ã„ã‚‹ã€ŒNinjaGuild_Japanã€ã ã€‚
          æµ·å¤–AIæƒ…å ±ã‚’æš—å·è³‡ç”£æŠ•è³‡å®¶ç›®ç·šã§æ—¥æœ¬èªåœã«ç´¹ä»‹ã™ã‚‹ã€‚ãŸã ã®ç¿»è¨³ã§ã¯ãªãå¸‚å ´ã¸ã®å½±éŸ¿ã‚’åŠ ãˆã‚ã€‚

          ãƒ«ãƒ¼ãƒ«: 250å­—ä»¥å†…ã€æ—¥æœ¬èªã®ã¿ï¼ˆå›ºæœ‰åè©OKï¼‰ã€URLç¦æ­¢ã€ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ç¦æ­¢ã€å¸¸ä½“ã§æ›¸ã‘ã€‚
          ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: {tname}({tid})

          å…ƒãƒ„ã‚¤ãƒ¼ãƒˆ @{tweet['author_username']} (â¤ï¸{tweet['likes']:,}):
          {tweet['text']}

          ãƒ„ã‚¤ãƒ¼ãƒˆæœ¬æ–‡ã ã‘ã‚’å‡ºåŠ›ã—ã‚ã€‚ä½™è¨ˆãªèª¬æ˜ã¯ä¸€åˆ‡ä¸è¦ã€‚"""

              print(f"  ğŸ“ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: {tname}")
              for attempt in range(3):
                  try:
                      response = client.models.generate_content(model="gemini-2.5-flash", contents=prompt)
                      text = response.text.strip()
                      text = re.sub(r'^```.*?\n','',text); text = re.sub(r'\n```$','',text)
                      text = text.strip('"\'`')
                      if len(text) > 250: text = text[:247] + "..."
                      print(f"  âœ… ç”Ÿæˆå®Œäº†ï¼ˆ{len(text)}å­—ï¼‰")
                      print(f"  ---\n  {text}\n  ---")
                      return {"text": text, "tweet_id": tweet["id"]}
                  except Exception as e:
                      print(f"  âš ï¸ Gemini APIã‚¨ãƒ©ãƒ¼ï¼ˆ{attempt+1}/3ï¼‰: {e}")
                      if attempt < 2: time.sleep(2**attempt)
              return {"text": "", "error": "ç”Ÿæˆå¤±æ•—"}

          def post_quote_rt(text, quote_tweet_id):
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("ğŸ“¤ å¼•ç”¨RTæŠ•ç¨¿")
              print("="*50)
              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)
              resp = session.post("https://api.twitter.com/2/tweets",
                  json={"text": text, "quote_tweet_id": quote_tweet_id})
              if resp.status_code in (200, 201):
                  tid = resp.json().get("data",{}).get("id","")
                  print(f"  âœ… æŠ•ç¨¿æˆåŠŸ! https://x.com/i/status/{tid}")
                  return {"success": True, "id": tid}
              else:
                  print(f"  âŒ æŠ•ç¨¿å¤±æ•—: {resp.status_code} {resp.json()}")
                  return {"success": False, "status": resp.status_code}

          if __name__ == "__main__":
              parser = argparse.ArgumentParser()
              parser.add_argument("--post-test", action="store_true")
              parser.add_argument("--collect", action="store_true")
              parser.add_argument("--dry-run", action="store_true")
              parser.add_argument("--auto", action="store_true")
              parser.add_argument("--min-likes", type=int, default=100)
              args = parser.parse_args()

              print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
              print("â•‘  X Quote RT Mini â€” ãƒŸãƒ‹ãƒãƒ ç‰ˆå¼•ç”¨RTãƒ„ãƒ¼ãƒ«    â•‘")
              print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              check_env()

              if args.post_test:
                  sys.exit(0 if post_test() else 1)

              tweets = collect_tweets(min_likes=args.min_likes)
              if not tweets:
                  print("âŒ ãƒã‚ºãƒ„ã‚¤ãƒ¼ãƒˆãªã—"); sys.exit(1)
              if args.collect:
                  sys.exit(0)

              selected = tweets[0]
              result = generate_comment(selected)
              if not result.get("text"):
                  print("âŒ ç”Ÿæˆå¤±æ•—"); sys.exit(1)
              if args.dry_run:
                  print("âœ… ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³å®Œäº†"); sys.exit(0)

              post_result = post_quote_rt(result["text"], selected["id"])
              sys.exit(0 if post_result.get("success") else 1)
          PYEOF

      - name: Run mini tool
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCOUNT_1_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCOUNT_1_ACCESS_SECRET }}
          TWITTER_BEARER_TOKEN: ${{ secrets.TWITTER_BEARER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          case "${{ github.event.inputs.mode }}" in
            post-test)
              python run_mini.py --post-test
              ;;
            collect-only)
              python run_mini.py --collect --min-likes 100
              ;;
            dry-run)
              python run_mini.py --dry-run --auto --min-likes 100
              ;;
          esac
