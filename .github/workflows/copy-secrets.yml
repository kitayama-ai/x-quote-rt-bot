name: "Run Mini Tool Test"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "„ÉÜ„Çπ„Éà„É¢„Éº„Éâ"
        required: true
        default: "dry-run"
        type: choice
        options:
          - post-test
          - collect-only
          - dry-run
          - metrics-debug
          - full-auto

jobs:
  test-mini:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install tweepy requests-oauthlib google-genai python-dotenv

      - name: Create mini tool
        run: |
          cat > run_mini.py << 'PYEOF'
          #!/usr/bin/env python3
          """X Quote RT Mini ‚Äî „Ç§„É≥„É©„Ç§„É≥ÁâàÔºàGitHub ActionsÁî®Ôºâ

          Áô∫Ë¶ã: X API Free „Éó„É©„É≥„Åß„ÅØ public_metrics „ÅåÂÖ®„Å¶0„ÅßËøî„Çã„ÄÇ
          „Åù„ÅÆ„Åü„ÇÅ min_likes „Éï„Ç£„É´„Çø„ÅØ‰Ωø„Çè„Åö„ÄÅÂÖ®‰ª∂„ÇíÂØæË±°„Å´„Åô„Çã„ÄÇ
          „ÉÑ„Ç§„Éº„Éà„ÅÆÂìÅË≥™„ÅØ„ÉÜ„Ç≠„Çπ„ÉàÂÜÖÂÆπ„Å®API„ÅÆ relevancy „ÇΩ„Éº„Éà„Å´‰æùÂ≠ò„ÄÇ
          """
          import argparse, json, os, random, re, sys, time
          from datetime import datetime, timezone

          # Áí∞Â¢ÉÂ§âÊï∞
          X_API_KEY = os.getenv("X_API_KEY", "")
          X_API_SECRET = os.getenv("X_API_SECRET", "")
          X_ACCESS_TOKEN = os.getenv("X_ACCESS_TOKEN", "")
          X_ACCESS_SECRET = os.getenv("X_ACCESS_SECRET", "")
          TWITTER_BEARER_TOKEN = os.getenv("TWITTER_BEARER_TOKEN", "")
          GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")

          def check_env():
              envs = {"X_API_KEY": X_API_KEY, "X_API_SECRET": X_API_SECRET,
                      "X_ACCESS_TOKEN": X_ACCESS_TOKEN, "X_ACCESS_SECRET": X_ACCESS_SECRET,
                      "TWITTER_BEARER_TOKEN": TWITTER_BEARER_TOKEN, "GEMINI_API_KEY": GEMINI_API_KEY}
              missing = [k for k,v in envs.items() if not v]
              if missing:
                  print(f"‚ùå Êú™Ë®≠ÂÆö: {', '.join(missing)}")
                  sys.exit(1)
              for k,v in envs.items():
                  print(f"  ‚úÖ {k}: {v[:6]}...{v[-3:]} ({len(v)}Â≠ó)")

          def post_test():
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("üß™ ÊäïÁ®ø„ÉÜ„Çπ„ÉàÔºà„ÉÑ„Ç§„Éº„Éà„ÅØÊÆã„ÅôÔºâ")
              print("="*50)
              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)
              # 1. „Ç¢„Ç´„Ç¶„É≥„ÉàÁ¢∫Ë™ç
              print("  1Ô∏è‚É£ „Ç¢„Ç´„Ç¶„É≥„ÉàÁ¢∫Ë™ç...")
              me_resp = session.get("https://api.twitter.com/2/users/me")
              if me_resp.status_code == 200:
                  me = me_resp.json().get("data", {})
                  print(f"     ‚úÖ @{me.get('username','?')} ({me.get('name','?')})")
              else:
                  print(f"     ‚ö†Ô∏è GET /users/me: {me_resp.status_code}")
              # 2. „ÉÜ„Çπ„ÉàÊäïÁ®øÔºàÂâäÈô§„Åó„Å™„ÅÑÔºâ
              print("  2Ô∏è‚É£ „ÉÜ„Çπ„ÉàÊäïÁ®ø...")
              test_text = f"üß™ „ÉÜ„Çπ„ÉàÊäïÁ®ø {datetime.now(timezone.utc).strftime('%m/%d %H:%M')} UTC ‚Äî Âãï‰ΩúÁ¢∫Ë™çÁî®"
              resp = session.post("https://api.twitter.com/2/tweets", json={"text": test_text})
              if resp.status_code not in (200, 201):
                  print(f"     ‚ùå ÊäïÁ®øÂ§±Êïó: {resp.status_code} {resp.json()}")
                  return False
              tweet_id = resp.json().get("data",{}).get("id","")
              print(f"     ‚úÖ ÊäïÁ®øÊàêÂäüÔºÅÂâäÈô§„Åõ„Åö„Å´ÊÆã„Åó„Åæ„Åô")
              print(f"     üîó https://x.com/i/status/{tweet_id}")
              print(f"\n  üéâ Ë™çË®ºOKÔºÅÊäïÁ®ø„Åß„Åç„Åæ„Åó„ÅüÔºÅ")
              return True

          def collect_tweets(max_tweets=10, min_likes=100):
              """requestsÁõ¥Êé•Áâà: tweepy„ÅØpublic_metrics„Çí0„ÅßËøî„Åô„Éê„Ç∞„ÅÇ„Çä"""
              import requests as req
              print("\n" + "="*50)
              print("üì° „Éê„Ç∫„ÉÑ„Ç§„Éº„ÉàÂèéÈõÜÔºàrequestsÁõ¥Êé•ÁâàÔºâ")
              print("="*50)

              headers = {"Authorization": f"Bearer {TWITTER_BEARER_TOKEN}"}
              base_url = "https://api.twitter.com/2/tweets/search/recent"
              queries = [
                  "(GPT-5 OR GPT5 OR Claude OR Gemini OR AGI) -is:reply -is:retweet lang:en",
                  "(OpenAI OR Anthropic OR DeepMind OR \"AI agent\") -is:reply -is:retweet lang:en",
                  "(Bitcoin OR BTC OR Ethereum OR crypto) -is:reply -is:retweet lang:en",
              ]

              all_tweets = []
              for qi, query in enumerate(queries):
                  print(f"  üîç „ÇØ„Ç®„É™ {qi+1}: {query[:60]}...")
                  params = {
                      "query": query, "max_results": min(max_tweets, 100),
                      "tweet.fields": "created_at,public_metrics,author_id,lang,text",
                      "user.fields": "username,name,public_metrics",
                      "expansions": "author_id", "sort_order": "relevancy",
                  }
                  try:
                      resp = req.get(base_url, headers=headers, params=params, timeout=30)
                  except Exception as e:
                      print(f"  ‚ö†Ô∏è „Ç®„É©„Éº: {e}"); continue
                  if resp.status_code != 200:
                      print(f"  ‚ö†Ô∏è {resp.status_code}"); continue

                  data = resp.json()
                  tweets = data.get("data", [])
                  if not tweets:
                      print("  ‚Üí ÁµêÊûú„Å™„Åó"); continue

                  users = {}
                  for u in data.get("includes", {}).get("users", []):
                      u_pm = u.get("public_metrics", {})
                      users[u["id"]] = {"username": u.get("username","?"), "name": u.get("name",""), "followers": u_pm.get("followers_count",0)}

                  filtered = 0
                  for tweet in tweets:
                      pm = tweet.get("public_metrics", {})
                      likes = pm.get("like_count", 0)
                      text = tweet.get("text", "")
                      user = users.get(tweet.get("author_id",""), {})
                      if len(text) < 30 or text.count("http") > 2 or text.count("@") > 3: continue
                      if likes < min_likes: filtered += 1; continue
                      all_tweets.append({
                          "id": tweet["id"], "text": text, "likes": likes,
                          "retweets": pm.get("retweet_count",0),
                          "author_username": user.get("username","?"),
                          "author_name": user.get("name",""),
                          "followers": user.get("followers",0),
                      })
                  print(f"  ‚Üí {len(tweets)}‰ª∂, {min_likes}‚ù§Ô∏è‰ª•‰∏ä: {len(tweets)-filtered}‰ª∂")

              seen = set(); unique = []
              for t in all_tweets:
                  if t["id"] not in seen: seen.add(t["id"]); unique.append(t)
              unique.sort(key=lambda x: x["likes"], reverse=True)

              print(f"\nüìä ÂèéÈõÜÁµêÊûú: {len(unique)}‰ª∂Ôºà{min_likes}„ÅÑ„ÅÑ„Å≠‰ª•‰∏äÔºâ")
              for i, t in enumerate(unique[:5]):
                  print(f"  [{i+1}] ‚ù§Ô∏è{t['likes']:,} üîÑ{t['retweets']:,} @{t['author_username']}")
                  print(f"      {t['text'][:100]}...")
              return unique

          def generate_comment(tweet):
              from google import genai
              print("\n" + "="*50)
              print("ü§ñ ÂºïÁî®RT„Ç≥„É°„É≥„ÉàÁîüÊàê")
              print("="*50)

              client = genai.Client(api_key=GEMINI_API_KEY)
              templates = [
                  ("translate_comment","Â∏ÇÂ†¥„Ç§„É≥„Éë„ÇØ„ÉàÂûã"),
                  ("summary_points","Ë¶ÅÁÇπ„Åæ„Å®„ÇÅÂûã"),
                  ("breaking_news","Ë°ùÊíÉÈÄüÂ†±Âûã"),
                  ("dark_alert","„ÉÄ„Éº„ÇØË≠¶ÂëäÂûã"),
              ]
              tid, tname = random.choice(templates)
              prompt = f"""„ÅÇ„Å™„Åü„ÅØùïè„ÅßÊöóÂè∑Ë≥áÁî£„ÉªWeb3„ÉªAI„Çí„ÉÜ„Éº„Éû„Å´Áô∫‰ø°„Åó„Å¶„ÅÑ„Çã„ÄåNinjaGuild_Japan„Äç„Å†„ÄÇ
          Êµ∑Â§ñAIÊÉÖÂ†±„ÇíÊöóÂè∑Ë≥áÁî£ÊäïË≥áÂÆ∂ÁõÆÁ∑ö„ÅßÊó•Êú¨Ë™ûÂúè„Å´Á¥π‰ªã„Åô„Çã„ÄÇ„Åü„Å†„ÅÆÁøªË®≥„Åß„ÅØ„Å™„ÅèÂ∏ÇÂ†¥„Å∏„ÅÆÂΩ±Èüø„ÇíÂä†„Åà„Çç„ÄÇ

          „É´„Éº„É´: ÂøÖ„Åö120Â≠ó‰ª•ÂÜÖÔºàË∂Ö„Åà„Åü„ÇâÂàá„Çå„ÇãÔºâ„ÄÅÊó•Êú¨Ë™û„ÅÆ„ÅøÔºàÂõ∫ÊúâÂêçË©ûOKÔºâ„ÄÅURLÁ¶ÅÊ≠¢„ÄÅ„Éè„ÉÉ„Ç∑„É•„Çø„Ç∞Á¶ÅÊ≠¢„ÄÅÂ∏∏‰Ωì„ÅßÊõ∏„Åë„ÄÇ
          ‚ÄªX API„ÅÆÊñáÂ≠ó„Ç´„Ç¶„É≥„ÉàÂà∂Èôê„ÅÆ„Åü„ÇÅÂøÖ„Åö120Â≠ó‰ª•ÂÜÖ„Å´Âèé„ÇÅ„Çã„Åì„Å®„ÄÇ
          „ÉÜ„É≥„Éó„É¨„Éº„Éà: {tname}({tid})

          ÂÖÉ„ÉÑ„Ç§„Éº„Éà @{tweet['author_username']}:
          {tweet['text']}

          „ÉÑ„Ç§„Éº„ÉàÊú¨Êñá„Å†„Åë„ÇíÂá∫Âäõ„Åó„Çç„ÄÇ‰ΩôË®à„Å™Ë™¨Êòé„ÅØ‰∏ÄÂàá‰∏çË¶Å„ÄÇ"""

              print(f"  üìù „ÉÜ„É≥„Éó„É¨„Éº„Éà: {tname}")
              print(f"  üéØ ÂØæË±°: @{tweet['author_username']}")
              for attempt in range(3):
                  try:
                      response = client.models.generate_content(model="gemini-2.5-flash", contents=prompt)
                      text = response.text.strip()
                      text = re.sub(r'^```.*?\n','',text); text = re.sub(r'\n```$','',text)
                      text = text.strip('"\'`')
                      # X API: Êó•Êú¨Ë™û„ÅØ1ÊñáÂ≠ó=2„Ç´„Ç¶„É≥„Éà„ÄÇquote_tweet_idÂàÜURL(23)Âê´„ÇÅ280‰ª•ÂÜÖ„Å´Âèé„ÇÅ„Çã
                      # ÂÆâÂÖ®‰∏äÈôê: 120ÊñáÂ≠óÔºà120√ó2+23=263„Ç´„Ç¶„É≥„Éà ‚â§ 280Ôºâ
                      if len(text) > 120: text = text[:117] + "..."
                      print(f"\n  ‚úÖ ÁîüÊàêÂÆå‰∫ÜÔºà{len(text)}Â≠ó ‚âí {len(text)*2+23}„Ç´„Ç¶„É≥„ÉàÔºâ")
                      print(f"  ---")
                      for line in text.split('\n'):
                          print(f"  {line}")
                      print(f"  ---")
                      return {"text": text, "tweet_id": tweet["id"], "template": tname}
                  except Exception as e:
                      print(f"  ‚ö†Ô∏è Gemini API„Ç®„É©„ÉºÔºà{attempt+1}/3Ôºâ: {e}")
                      if attempt < 2: time.sleep(2**attempt)
              return {"text": "", "error": "ÁîüÊàêÂ§±Êïó"}

          def post_quote_rt(text, quote_tweet_id, author_username=""):
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("üì§ ÂºïÁî®RTÊäïÁ®ø")
              print("="*50)
              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)
              print(f"  üìé ÂºïÁî®ÂÖÉ: https://x.com/{author_username}/status/{quote_tweet_id}")
              print(f"  üìù „ÉÜ„Ç≠„Çπ„Éà: {len(text)}Â≠ó ‚âí {len(text)*2+23}„Ç´„Ç¶„É≥„ÉàÔºà‰∏äÈôê280Ôºâ")
              resp = session.post("https://api.twitter.com/2/tweets",
                  json={"text": text, "quote_tweet_id": str(quote_tweet_id)})
              if resp.status_code in (200, 201):
                  tid = resp.json().get("data",{}).get("id","")
                  print(f"  ‚úÖ ÊäïÁ®øÊàêÂäü! https://x.com/i/status/{tid}")
                  return {"success": True, "id": tid}
              else:
                  print(f"  ‚ùå ÊäïÁ®øÂ§±Êïó: {resp.status_code} {resp.json()}")
                  return {"success": False, "status": resp.status_code}

          if __name__ == "__main__":
              parser = argparse.ArgumentParser()
              parser.add_argument("--post-test", action="store_true")
              parser.add_argument("--collect", action="store_true")
              parser.add_argument("--dry-run", action="store_true")
              parser.add_argument("--auto", action="store_true")
              args = parser.parse_args()

              print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
              print("‚ïë  X Quote RT Mini ‚Äî „Éü„Éã„Éû„É†ÁâàÂºïÁî®RT„ÉÑ„Éº„É´    ‚ïë")
              print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
              check_env()

              if args.post_test:
                  sys.exit(0 if post_test() else 1)

              tweets = collect_tweets()
              if not tweets:
                  print("‚ùå „ÉÑ„Ç§„Éº„Éà„Å™„Åó"); sys.exit(1)
              if args.collect:
                  sys.exit(0)

              # ‰∏ä‰Ωç2‰ª∂„ÇíÈÅ∏„Çì„ÅßÊäïÁ®ø
              targets = tweets[:2]
              if args.dry_run:
                  for i, selected in enumerate(targets, 1):
                      result = generate_comment(selected)
                      print(f"\n‚úÖ „Éâ„É©„Ç§„É©„É≥ {i}‰ª∂ÁõÆ")
                      print(f"   „ÉÜ„É≥„Éó„É¨„Éº„Éà: {result.get('template','?')}")
                      print(f"   ÂºïÁî®ÂÖÉ: https://x.com/{selected['author_username']}/status/{selected['id']}")
                  sys.exit(0)

              success_count = 0
              for i, selected in enumerate(targets, 1):
                  print(f"\n{'='*50}")
                  print(f"üì§ {i}‰ª∂ÁõÆ ÊäïÁ®ø‰∏≠...")
                  result = generate_comment(selected)
                  if not result.get("text"):
                      print(f"‚ùå {i}‰ª∂ÁõÆ ÁîüÊàêÂ§±Êïó"); continue
                  time.sleep(5)  # ÈÄ£ÊäïÈò≤Ê≠¢Ôºà5ÁßíÂæÖÊ©üÔºâ
                  post_result = post_quote_rt(result["text"], selected["id"], selected.get("author_username",""))
                  if post_result.get("success"):
                      success_count += 1
              print(f"\nüéâ ÂÆå‰∫Ü: {success_count}/{len(targets)}‰ª∂ ÊäïÁ®øÊàêÂäü")
              sys.exit(0 if success_count > 0 else 1)
          PYEOF

      - name: Run mini tool
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCOUNT_1_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCOUNT_1_ACCESS_SECRET }}
          TWITTER_BEARER_TOKEN: ${{ secrets.TWITTER_BEARER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          case "${{ github.event.inputs.mode }}" in
            post-test)
              python run_mini.py --post-test
              ;;
            collect-only)
              python run_mini.py --collect
              ;;
            dry-run)
              python run_mini.py --dry-run --auto
              ;;
            metrics-debug)
              python3 << 'DEBUGEOF'
          import os, json, requests

          bearer = os.getenv("TWITTER_BEARER_TOKEN", "")
          print("=" * 50)
          print("üîç public_metrics Ë®∫Êñ≠")
          print("=" * 50)

          # Raw HTTP „ÅßÁõ¥Êé• API „ÇíÂè©„ÅèÔºàtweepy „Çí‰ªã„Åï„Å™„ÅÑÔºâ
          headers = {"Authorization": f"Bearer {bearer}"}
          params = {
              "query": "OpenAI -is:reply -is:retweet lang:en",
              "max_results": 10,
              "tweet.fields": "public_metrics,created_at,author_id",
              "user.fields": "username,name,public_metrics",
              "expansions": "author_id",
              "sort_order": "relevancy",
          }

          print(f"\n  üì° GET /2/tweets/search/recent")
          print(f"  Query: {params['query']}")
          print(f"  tweet.fields: {params['tweet.fields']}")
          resp = requests.get(
              "https://api.twitter.com/2/tweets/search/recent",
              headers=headers, params=params
          )

          print(f"\n  Status: {resp.status_code}")
          data = resp.json()

          # „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„É°„ÇøÊÉÖÂ†±
          if "meta" in data:
              print(f"  Meta: {json.dumps(data['meta'], indent=2)}")

          # „Ç®„É©„Éº„ÉÅ„Çß„ÉÉ„ÇØ
          if "errors" in data:
              print(f"\n  ‚ö†Ô∏è Errors:")
              for err in data["errors"][:3]:
                  print(f"    - {err}")

          # „ÉÑ„Ç§„Éº„Éà„Éá„Éº„Çø
          tweets = data.get("data", [])
          print(f"\n  üìä ÂèñÂæó„ÉÑ„Ç§„Éº„ÉàÊï∞: {len(tweets)}")

          # „É¶„Éº„Ç∂„Éº„Éá„Éº„Çø
          users = {}
          for u in data.get("includes", {}).get("users", []):
              users[u["id"]] = u

          for i, t in enumerate(tweets[:5]):
              pm = t.get("public_metrics", {})
              author = users.get(t.get("author_id", ""), {})
              author_pm = author.get("public_metrics", {})
              print(f"\n  [{i+1}] Tweet ID: {t['id']}")
              print(f"      Author: @{author.get('username', '?')}")
              print(f"      Author followers: {author_pm.get('followers_count', 'N/A')}")
              print(f"      Text: {t['text'][:80]}...")
              print(f"      public_metrics (raw):")
              print(f"        like_count:    {pm.get('like_count', 'MISSING')}")
              print(f"        retweet_count: {pm.get('retweet_count', 'MISSING')}")
              print(f"        reply_count:   {pm.get('reply_count', 'MISSING')}")
              print(f"        quote_count:   {pm.get('quote_count', 'MISSING')}")
              print(f"        impression_count: {pm.get('impression_count', 'MISSING')}")
              print(f"        bookmark_count:  {pm.get('bookmark_count', 'MISSING')}")

          # Raw JSON (ÊúÄÂàù„ÅÆ2‰ª∂„Å†„Åë)
          print(f"\n  === Raw JSON (ÂÖàÈ†≠2‰ª∂) ===")
          for t in tweets[:2]:
              print(f"  {json.dumps(t, indent=2, ensure_ascii=False)[:500]}")
          DEBUGEOF
              ;;
            full-auto)
              python run_mini.py --auto
              ;;
          esac
