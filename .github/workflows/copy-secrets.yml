name: "Run Mini Tool Test"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰"
        required: true
        default: "dry-run"
        type: choice
        options:
          - post-test
          - collect-only
          - dry-run
          - metrics-debug

jobs:
  test-mini:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install tweepy requests-oauthlib google-genai python-dotenv

      - name: Create mini tool
        run: |
          cat > run_mini.py << 'PYEOF'
          #!/usr/bin/env python3
          """X Quote RT Mini â€” ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ç‰ˆï¼ˆGitHub Actionsç”¨ï¼‰

          ç™ºè¦‹: X API Free ãƒ—ãƒ©ãƒ³ã§ã¯ public_metrics ãŒå…¨ã¦0ã§è¿”ã‚‹ã€‚
          ãã®ãŸã‚ min_likes ãƒ•ã‚£ãƒ«ã‚¿ã¯ä½¿ã‚ãšã€å…¨ä»¶ã‚’å¯¾è±¡ã«ã™ã‚‹ã€‚
          ãƒ„ã‚¤ãƒ¼ãƒˆã®å“è³ªã¯ãƒ†ã‚­ã‚¹ãƒˆå†…å®¹ã¨APIã® relevancy ã‚½ãƒ¼ãƒˆã«ä¾å­˜ã€‚
          """
          import argparse, json, os, random, re, sys, time
          from datetime import datetime, timezone

          # ç’°å¢ƒå¤‰æ•°
          X_API_KEY = os.getenv("X_API_KEY", "")
          X_API_SECRET = os.getenv("X_API_SECRET", "")
          X_ACCESS_TOKEN = os.getenv("X_ACCESS_TOKEN", "")
          X_ACCESS_SECRET = os.getenv("X_ACCESS_SECRET", "")
          TWITTER_BEARER_TOKEN = os.getenv("TWITTER_BEARER_TOKEN", "")
          GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")

          def check_env():
              envs = {"X_API_KEY": X_API_KEY, "X_API_SECRET": X_API_SECRET,
                      "X_ACCESS_TOKEN": X_ACCESS_TOKEN, "X_ACCESS_SECRET": X_ACCESS_SECRET,
                      "TWITTER_BEARER_TOKEN": TWITTER_BEARER_TOKEN, "GEMINI_API_KEY": GEMINI_API_KEY}
              missing = [k for k,v in envs.items() if not v]
              if missing:
                  print(f"âŒ æœªè¨­å®š: {', '.join(missing)}")
                  sys.exit(1)
              for k,v in envs.items():
                  print(f"  âœ… {k}: {v[:6]}...{v[-3:]} ({len(v)}å­—)")

          def post_test():
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("ğŸ§ª æŠ•ç¨¿ãƒ†ã‚¹ãƒˆï¼ˆå³å‰Šé™¤ï¼‰")
              print("="*50)
              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)
              # 1. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç¢ºèª
              print("  1ï¸âƒ£ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç¢ºèª...")
              me_resp = session.get("https://api.twitter.com/2/users/me")
              if me_resp.status_code == 200:
                  me = me_resp.json().get("data", {})
                  print(f"     âœ… @{me.get('username','?')} ({me.get('name','?')})")
              else:
                  print(f"     âš ï¸ GET /users/me: {me_resp.status_code}")
              # 2. ãƒ†ã‚¹ãƒˆæŠ•ç¨¿
              print("  2ï¸âƒ£ ãƒ†ã‚¹ãƒˆæŠ•ç¨¿...")
              test_text = f"ğŸ§ª Mini Test ({datetime.now(timezone.utc).isoformat()[:19]})"
              resp = session.post("https://api.twitter.com/2/tweets", json={"text": test_text})
              if resp.status_code not in (200, 201):
                  print(f"     âŒ æŠ•ç¨¿å¤±æ•—: {resp.status_code} {resp.json()}")
                  return False
              tweet_id = resp.json().get("data",{}).get("id","")
              print(f"     âœ… æŠ•ç¨¿æˆåŠŸ: {tweet_id}")
              # 3. å³å‰Šé™¤
              print("  3ï¸âƒ£ å³å‰Šé™¤...")
              time.sleep(1)
              del_resp = session.delete(f"https://api.twitter.com/2/tweets/{tweet_id}")
              print(f"     {'âœ…' if del_resp.status_code==200 else 'âš ï¸'} å‰Šé™¤: {del_resp.status_code}")
              # 4. å¼•ç”¨RTãƒ†ã‚¹ãƒˆ
              print("  4ï¸âƒ£ å¼•ç”¨RTãƒ†ã‚¹ãƒˆ...")
              qt_resp = session.post("https://api.twitter.com/2/tweets", json={
                  "text": f"ğŸ§ª Quote RT Test ({datetime.now(timezone.utc).isoformat()[:19]})",
                  "quote_tweet_id": "1585841080431321088",
              })
              if qt_resp.status_code in (200, 201):
                  qt_id = qt_resp.json().get("data",{}).get("id","")
                  print(f"     âœ… å¼•ç”¨RTæˆåŠŸ: {qt_id}")
                  time.sleep(1)
                  session.delete(f"https://api.twitter.com/2/tweets/{qt_id}")
                  print(f"     âœ… å‰Šé™¤å®Œäº†")
              else:
                  print(f"     âŒ å¼•ç”¨RTå¤±æ•—: {qt_resp.status_code} {qt_resp.json()}")
                  return False
              print(f"\n  ğŸ‰ å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼ï¼")
              return True

          def collect_tweets(max_tweets=10, min_likes=100):
              """requestsç›´æ¥ç‰ˆ: tweepyã¯public_metricsã‚’0ã§è¿”ã™ãƒã‚°ã‚ã‚Š"""
              import requests as req
              print("\n" + "="*50)
              print("ğŸ“¡ ãƒã‚ºãƒ„ã‚¤ãƒ¼ãƒˆåé›†ï¼ˆrequestsç›´æ¥ç‰ˆï¼‰")
              print("="*50)

              headers = {"Authorization": f"Bearer {TWITTER_BEARER_TOKEN}"}
              base_url = "https://api.twitter.com/2/tweets/search/recent"
              queries = [
                  "(GPT-5 OR GPT5 OR Claude OR Gemini OR AGI) -is:reply -is:retweet lang:en",
                  "(OpenAI OR Anthropic OR DeepMind OR \"AI agent\") -is:reply -is:retweet lang:en",
                  "(Bitcoin OR BTC OR Ethereum OR crypto) -is:reply -is:retweet lang:en",
              ]

              all_tweets = []
              for qi, query in enumerate(queries):
                  print(f"  ğŸ” ã‚¯ã‚¨ãƒª {qi+1}: {query[:60]}...")
                  params = {
                      "query": query, "max_results": min(max_tweets, 100),
                      "tweet.fields": "created_at,public_metrics,author_id,lang,text",
                      "user.fields": "username,name,public_metrics",
                      "expansions": "author_id", "sort_order": "relevancy",
                  }
                  try:
                      resp = req.get(base_url, headers=headers, params=params, timeout=30)
                  except Exception as e:
                      print(f"  âš ï¸ ã‚¨ãƒ©ãƒ¼: {e}"); continue
                  if resp.status_code != 200:
                      print(f"  âš ï¸ {resp.status_code}"); continue

                  data = resp.json()
                  tweets = data.get("data", [])
                  if not tweets:
                      print("  â†’ çµæœãªã—"); continue

                  users = {}
                  for u in data.get("includes", {}).get("users", []):
                      u_pm = u.get("public_metrics", {})
                      users[u["id"]] = {"username": u.get("username","?"), "name": u.get("name",""), "followers": u_pm.get("followers_count",0)}

                  filtered = 0
                  for tweet in tweets:
                      pm = tweet.get("public_metrics", {})
                      likes = pm.get("like_count", 0)
                      text = tweet.get("text", "")
                      user = users.get(tweet.get("author_id",""), {})
                      if len(text) < 30 or text.count("http") > 2 or text.count("@") > 3: continue
                      if likes < min_likes: filtered += 1; continue
                      all_tweets.append({
                          "id": tweet["id"], "text": text, "likes": likes,
                          "retweets": pm.get("retweet_count",0),
                          "author_username": user.get("username","?"),
                          "author_name": user.get("name",""),
                          "followers": user.get("followers",0),
                      })
                  print(f"  â†’ {len(tweets)}ä»¶, {min_likes}â¤ï¸ä»¥ä¸Š: {len(tweets)-filtered}ä»¶")

              seen = set(); unique = []
              for t in all_tweets:
                  if t["id"] not in seen: seen.add(t["id"]); unique.append(t)
              unique.sort(key=lambda x: x["likes"], reverse=True)

              print(f"\nğŸ“Š åé›†çµæœ: {len(unique)}ä»¶ï¼ˆ{min_likes}ã„ã„ã­ä»¥ä¸Šï¼‰")
              for i, t in enumerate(unique[:5]):
                  print(f"  [{i+1}] â¤ï¸{t['likes']:,} ğŸ”„{t['retweets']:,} @{t['author_username']}")
                  print(f"      {t['text'][:100]}...")
              return unique

          def generate_comment(tweet):
              from google import genai
              print("\n" + "="*50)
              print("ğŸ¤– å¼•ç”¨RTã‚³ãƒ¡ãƒ³ãƒˆç”Ÿæˆ")
              print("="*50)

              client = genai.Client(api_key=GEMINI_API_KEY)
              templates = [
                  ("translate_comment","å¸‚å ´ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆå‹"),
                  ("summary_points","è¦ç‚¹ã¾ã¨ã‚å‹"),
                  ("breaking_news","è¡æ’ƒé€Ÿå ±å‹"),
                  ("dark_alert","ãƒ€ãƒ¼ã‚¯è­¦å‘Šå‹"),
              ]
              tid, tname = random.choice(templates)
              prompt = f"""ã‚ãªãŸã¯ğ•ã§æš—å·è³‡ç”£ãƒ»Web3ãƒ»AIã‚’ãƒ†ãƒ¼ãƒã«ç™ºä¿¡ã—ã¦ã„ã‚‹ã€ŒNinjaGuild_Japanã€ã ã€‚
          æµ·å¤–AIæƒ…å ±ã‚’æš—å·è³‡ç”£æŠ•è³‡å®¶ç›®ç·šã§æ—¥æœ¬èªåœã«ç´¹ä»‹ã™ã‚‹ã€‚ãŸã ã®ç¿»è¨³ã§ã¯ãªãå¸‚å ´ã¸ã®å½±éŸ¿ã‚’åŠ ãˆã‚ã€‚

          ãƒ«ãƒ¼ãƒ«: 250å­—ä»¥å†…ã€æ—¥æœ¬èªã®ã¿ï¼ˆå›ºæœ‰åè©OKï¼‰ã€URLç¦æ­¢ã€ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ç¦æ­¢ã€å¸¸ä½“ã§æ›¸ã‘ã€‚
          ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: {tname}({tid})

          å…ƒãƒ„ã‚¤ãƒ¼ãƒˆ @{tweet['author_username']}:
          {tweet['text']}

          ãƒ„ã‚¤ãƒ¼ãƒˆæœ¬æ–‡ã ã‘ã‚’å‡ºåŠ›ã—ã‚ã€‚ä½™è¨ˆãªèª¬æ˜ã¯ä¸€åˆ‡ä¸è¦ã€‚"""

              print(f"  ğŸ“ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: {tname}")
              print(f"  ğŸ¯ å¯¾è±¡: @{tweet['author_username']}")
              for attempt in range(3):
                  try:
                      response = client.models.generate_content(model="gemini-2.5-flash", contents=prompt)
                      text = response.text.strip()
                      text = re.sub(r'^```.*?\n','',text); text = re.sub(r'\n```$','',text)
                      text = text.strip('"\'`')
                      if len(text) > 250: text = text[:247] + "..."
                      print(f"\n  âœ… ç”Ÿæˆå®Œäº†ï¼ˆ{len(text)}å­—ï¼‰")
                      print(f"  ---")
                      for line in text.split('\n'):
                          print(f"  {line}")
                      print(f"  ---")
                      return {"text": text, "tweet_id": tweet["id"], "template": tname}
                  except Exception as e:
                      print(f"  âš ï¸ Gemini APIã‚¨ãƒ©ãƒ¼ï¼ˆ{attempt+1}/3ï¼‰: {e}")
                      if attempt < 2: time.sleep(2**attempt)
              return {"text": "", "error": "ç”Ÿæˆå¤±æ•—"}

          def post_quote_rt(text, quote_tweet_id):
              from requests_oauthlib import OAuth1Session
              print("\n" + "="*50)
              print("ğŸ“¤ å¼•ç”¨RTæŠ•ç¨¿")
              print("="*50)
              session = OAuth1Session(X_API_KEY, client_secret=X_API_SECRET,
                  resource_owner_key=X_ACCESS_TOKEN, resource_owner_secret=X_ACCESS_SECRET)
              resp = session.post("https://api.twitter.com/2/tweets",
                  json={"text": text, "quote_tweet_id": quote_tweet_id})
              if resp.status_code in (200, 201):
                  tid = resp.json().get("data",{}).get("id","")
                  print(f"  âœ… æŠ•ç¨¿æˆåŠŸ! https://x.com/i/status/{tid}")
                  return {"success": True, "id": tid}
              else:
                  print(f"  âŒ æŠ•ç¨¿å¤±æ•—: {resp.status_code} {resp.json()}")
                  return {"success": False, "status": resp.status_code}

          if __name__ == "__main__":
              parser = argparse.ArgumentParser()
              parser.add_argument("--post-test", action="store_true")
              parser.add_argument("--collect", action="store_true")
              parser.add_argument("--dry-run", action="store_true")
              parser.add_argument("--auto", action="store_true")
              args = parser.parse_args()

              print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
              print("â•‘  X Quote RT Mini â€” ãƒŸãƒ‹ãƒãƒ ç‰ˆå¼•ç”¨RTãƒ„ãƒ¼ãƒ«    â•‘")
              print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
              check_env()

              if args.post_test:
                  sys.exit(0 if post_test() else 1)

              tweets = collect_tweets()
              if not tweets:
                  print("âŒ ãƒ„ã‚¤ãƒ¼ãƒˆãªã—"); sys.exit(1)
              if args.collect:
                  sys.exit(0)

              selected = tweets[0]
              result = generate_comment(selected)
              if not result.get("text"):
                  print("âŒ ç”Ÿæˆå¤±æ•—"); sys.exit(1)
              if args.dry_run:
                  print(f"\nâœ… ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³å®Œäº†")
                  print(f"   ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: {result.get('template','?')}")
                  print(f"   å¼•ç”¨å…ƒ: https://x.com/{selected['author_username']}/status/{selected['id']}")
                  sys.exit(0)

              post_result = post_quote_rt(result["text"], selected["id"])
              sys.exit(0 if post_result.get("success") else 1)
          PYEOF

      - name: Run mini tool
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCOUNT_1_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCOUNT_1_ACCESS_SECRET }}
          TWITTER_BEARER_TOKEN: ${{ secrets.TWITTER_BEARER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          case "${{ github.event.inputs.mode }}" in
            post-test)
              python run_mini.py --post-test
              ;;
            collect-only)
              python run_mini.py --collect
              ;;
            dry-run)
              python run_mini.py --dry-run --auto
              ;;
            metrics-debug)
              python3 << 'DEBUGEOF'
          import os, json, requests

          bearer = os.getenv("TWITTER_BEARER_TOKEN", "")
          print("=" * 50)
          print("ğŸ” public_metrics è¨ºæ–­")
          print("=" * 50)

          # Raw HTTP ã§ç›´æ¥ API ã‚’å©ãï¼ˆtweepy ã‚’ä»‹ã•ãªã„ï¼‰
          headers = {"Authorization": f"Bearer {bearer}"}
          params = {
              "query": "OpenAI -is:reply -is:retweet lang:en",
              "max_results": 10,
              "tweet.fields": "public_metrics,created_at,author_id",
              "user.fields": "username,name,public_metrics",
              "expansions": "author_id",
              "sort_order": "relevancy",
          }

          print(f"\n  ğŸ“¡ GET /2/tweets/search/recent")
          print(f"  Query: {params['query']}")
          print(f"  tweet.fields: {params['tweet.fields']}")
          resp = requests.get(
              "https://api.twitter.com/2/tweets/search/recent",
              headers=headers, params=params
          )

          print(f"\n  Status: {resp.status_code}")
          data = resp.json()

          # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ¡ã‚¿æƒ…å ±
          if "meta" in data:
              print(f"  Meta: {json.dumps(data['meta'], indent=2)}")

          # ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
          if "errors" in data:
              print(f"\n  âš ï¸ Errors:")
              for err in data["errors"][:3]:
                  print(f"    - {err}")

          # ãƒ„ã‚¤ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
          tweets = data.get("data", [])
          print(f"\n  ğŸ“Š å–å¾—ãƒ„ã‚¤ãƒ¼ãƒˆæ•°: {len(tweets)}")

          # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿
          users = {}
          for u in data.get("includes", {}).get("users", []):
              users[u["id"]] = u

          for i, t in enumerate(tweets[:5]):
              pm = t.get("public_metrics", {})
              author = users.get(t.get("author_id", ""), {})
              author_pm = author.get("public_metrics", {})
              print(f"\n  [{i+1}] Tweet ID: {t['id']}")
              print(f"      Author: @{author.get('username', '?')}")
              print(f"      Author followers: {author_pm.get('followers_count', 'N/A')}")
              print(f"      Text: {t['text'][:80]}...")
              print(f"      public_metrics (raw):")
              print(f"        like_count:    {pm.get('like_count', 'MISSING')}")
              print(f"        retweet_count: {pm.get('retweet_count', 'MISSING')}")
              print(f"        reply_count:   {pm.get('reply_count', 'MISSING')}")
              print(f"        quote_count:   {pm.get('quote_count', 'MISSING')}")
              print(f"        impression_count: {pm.get('impression_count', 'MISSING')}")
              print(f"        bookmark_count:  {pm.get('bookmark_count', 'MISSING')}")

          # Raw JSON (æœ€åˆã®2ä»¶ã ã‘)
          print(f"\n  === Raw JSON (å…ˆé ­2ä»¶) ===")
          for t in tweets[:2]:
              print(f"  {json.dumps(t, indent=2, ensure_ascii=False)[:500]}")
          DEBUGEOF
              ;;
          esac
